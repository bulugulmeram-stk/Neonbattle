<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON ARENA: CLOUD SAVE EDITION</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;500;700;900&display=swap');

        :root {
            --primary: #00f3ff;
            --secondary: #bc13fe;
            --bg-dark: #050505;
            --glass: rgba(10, 10, 15, 0.95);
            --glass-border: rgba(255, 255, 255, 0.15);
            --kp-color: #ffd700;
        }

        body {
            margin: 0; overflow: hidden; background-color: var(--bg-dark);
            font-family: 'Rajdhani', sans-serif; user-select: none; cursor: none;
        }
        body.in-menu { cursor: default; }
        canvas { display: block; }

        /* ARKA PLAN */
        .animated-bg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 50%, #1a1a2e 0%, #000000 100%);
            z-index: -1;
        }

        /* Y√úKLENƒ∞YOR EKRANI */
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050505; z-index: 1000; display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: var(--primary);
            font-size: 40px; font-weight: 900; letter-spacing: 5px;
        }
        .loader {
            border: 4px solid #333; border-top: 4px solid var(--primary);
            border-radius: 50%; width: 50px; height: 50px;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* MEN√ú GENEL */
        .menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 50; pointer-events: none; display: flex;
        }
        
        .menu-panel {
            width: 500px; height: 100%;
            background: linear-gradient(90deg, rgba(0,0,0,1) 0%, rgba(0,0,0,0.8) 100%);
            border-right: 2px solid var(--primary);
            display: flex; flex-direction: column; justify-content: center; padding-left: 50px;
            pointer-events: auto;
            box-shadow: 10px 0 50px rgba(0, 243, 255, 0.1);
        }

        .hidden { display: none !important; }

        .stats-display {
            font-size: 20px; color: #fff; margin-bottom: 20px; display: flex; gap: 20px;
        }
        .kp-text { color: var(--kp-color); text-shadow: 0 0 10px var(--kp-color); font-weight: bold; }

        .menu-title {
            font-size: 80px; line-height: 0.9; font-weight: 900; color: #fff;
            text-transform: uppercase; letter-spacing: -2px; margin-bottom: 40px;
        }
        .menu-title span { color: var(--primary); text-shadow: 0 0 20px var(--primary); }

        .menu-btn {
            background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #fff;
            padding: 15px 30px; font-size: 24px; font-family: 'Rajdhani'; font-weight: 700;
            margin: 10px 0; width: 300px; cursor: pointer; transition: 0.3s;
            text-align: left; text-transform: uppercase; pointer-events: auto;
        }
        .menu-btn:hover { background: rgba(0, 243, 255, 0.2); padding-left: 40px; border-color: var(--primary); }

        /* KARAKTER MEN√úS√ú */
        #char-menu {
            background: rgba(0,0,0,0.98); display: flex; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 60;
        }
        .char-menu-layout { display: flex; width: 80%; height: 80%; gap: 40px; }
        .char-list-container { flex: 1; display: flex; flex-direction: column; gap: 10px; overflow-y: auto; padding-right: 10px; }
        
        .char-list-item {
            background: rgba(255,255,255,0.05); border: 1px solid #333; padding: 15px 20px;
            display: flex; align-items: center; justify-content: space-between;
            cursor: pointer; transition: 0.2s; border-radius: 4px;
        }
        .char-list-item:hover { background: rgba(255,255,255,0.1); border-color: #fff; }
        .char-list-item.active { background: rgba(0, 243, 255, 0.15); border-color: var(--primary); }
        .char-list-item.locked { opacity: 0.5; filter: grayscale(1); }
        .item-name { font-size: 22px; font-weight: bold; color: white; }
        .item-role { font-size: 14px; color: #aaa; }

        .char-details-container {
            flex: 1; background: rgba(0,0,0,0.5); border: 1px solid var(--glass-border);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 20px; text-align: center; position: relative;
        }
        #char-preview-canvas { width: 200px; height: 200px; margin-bottom: 20px; }
        #detail-name { font-size: 50px; font-weight: 900; color: white; margin-bottom: 5px; }
        #detail-role { font-size: 20px; color: var(--primary); margin-bottom: 20px; }
        #detail-desc { font-size: 16px; color: #ccc; margin-bottom: 30px; line-height: 1.4; max-width: 80%; }
        
        .action-btn {
            padding: 15px 50px; font-size: 24px; font-weight: bold; text-transform: uppercase;
            cursor: pointer; border: none; border-radius: 4px; transition: 0.3s;
            font-family: 'Rajdhani'; margin-top: 20px; pointer-events: auto;
        }
        .btn-select { background: var(--primary); color: black; box-shadow: 0 0 20px var(--primary); }
        .btn-buy { background: var(--kp-color); color: black; box-shadow: 0 0 20px var(--kp-color); }
        .btn-locked { background: #333; color: #777; cursor: not-allowed; }

        /* OYUN UI */
        #game-ui { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; display: none; z-index: 10; }
        #game-ui > * { pointer-events: auto; }
        
        #top-bar { position: absolute; top: 30px; left: 40px; right: 40px; display: flex; justify-content: space-between; }
        .hud-box { font-size: 32px; font-weight: bold; color: white; text-shadow: 2px 2px 0 #000; }
        .kp-hud { font-size: 24px; color: var(--kp-color); font-weight: bold; }
        
        #health-container { width: 300px; height: 10px; background: #333; border: 1px solid #fff; margin-top: 5px; }
        #health-bar { width: 100%; height: 100%; background: var(--primary); transition: 0.2s; }

        #ui-layer { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; }
        .weapon-card { width: 60px; height: 60px; background: rgba(0,0,0,0.8); border: 1px solid #555; display: flex; align-items: center; justify-content: center; color: #888; cursor: pointer; pointer-events: auto; font-size: 24px; }
        .weapon-card.active { border-color: var(--primary); color: white; transform: scale(1.1); background: rgba(0,243,255,0.1); box-shadow: 0 0 15px rgba(0,243,255,0.3); }
        .weapon-card.locked { opacity: 0.3; cursor: not-allowed; }

        #skills-container { position: absolute; bottom: 30px; right: 30px; text-align: center; }
        #ability-icon { width: 70px; height: 70px; border: 2px solid #fff; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.5); position: relative; overflow: hidden; }
        #ability-cooldown { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: rgba(0,243,255,0.5); transition: height 0.1s; }
        #ability-text { font-size: 16px; color: var(--primary); font-weight: bold; margin-top: 5px; }

        /* Mƒ∞Nƒ∞ MAP */
        #minimap-container { position: absolute; bottom: 30px; left: 30px; width: 180px; height: 180px; background: rgba(5, 10, 15, 0.85); border: 2px solid var(--primary); border-radius: 50%; overflow: hidden; box-shadow: 0 0 20px rgba(0, 243, 255, 0.2); }
        #minimap-canvas { width: 100%; height: 100%; display: block; }

        /* TACTICAL MAP */
        #tactical-map { position: absolute; top:0; left:0; width:100%; height:100%; background: rgba(13, 0, 26, 0.85); display: none; cursor: crosshair; z-index: 100; background-image: linear-gradient(rgba(188, 19, 254, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(188, 19, 254, 0.1) 1px, transparent 1px); background-size: 50px 50px; }
        #tactical-text { position: absolute; top: 10%; left: 50%; transform: translateX(-50%); font-size: 40px; color: var(--secondary); font-weight: 900; text-shadow: 0 0 20px var(--secondary); text-align: center; }

        /* MODALLER */
        #level-up-screen, #game-over, #settings-menu, #resume-modal { 
            position: absolute; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.95);
            display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 70; pointer-events: auto;
        }
        .settings-panel { width: 400px; padding: 40px; border: 1px solid #444; text-align: center; background: #111; }
        
        .upgrade-card { 
            width: 240px; height: 340px; background: linear-gradient(145deg, #1a1a2e, #0d0d15); 
            border: 2px solid #333; margin: 15px; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; cursor: pointer; color: white; text-align: center; padding: 20px; 
            transition: 0.3s; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            opacity: 0; transform: translateY(50px) scale(0.8);
            animation: cardPopIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        .upgrade-card:hover { border-color: var(--kp-color); transform: scale(1.05) translateY(0) !important; box-shadow: 0 0 30px rgba(255, 215, 0, 0.2); background: #222; }
        .upgrade-card div:first-child { font-size: 60px; margin-bottom: 20px; text-shadow: 0 0 20px currentColor; }
        .upgrade-card div:last-child { font-size: 24px; font-weight: bold; color: #ddd; text-transform: uppercase; letter-spacing: 1px; }

        @keyframes cardPopIn { to { opacity: 1; transform: translateY(0) scale(1); } }

        #wave-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 120px; font-weight: 900; color: transparent; -webkit-text-stroke: 3px #fff; opacity: 0; pointer-events: none; transition: 0.5s; z-index: 100; }
        #wave-text.show { opacity: 1; letter-spacing: 15px; }

        #boss-ui { position: absolute; top: 100px; left: 50%; transform: translateX(-50%); width: 500px; text-align: center; display: none; z-index: 5; }
        #boss-bar-bg { width: 100%; height: 20px; background: #222; border: 2px solid #fff; border-radius: 10px; overflow: hidden; }
        #boss-bar { width: 100%; height: 100%; background: #ff003c; transition: width 0.1s; }

        #char-preview-container { position: absolute; right: 10%; top: 50%; transform: translateY(-50%); text-align: right; z-index: 15; }
        #preview-name { font-size: 80px; font-weight: 900; color: rgba(255,255,255,0.1); }

        input[type=range] { width: 100%; accent-color: var(--primary); margin: 10px 0; }
        select { width: 100%; padding: 10px; background: #222; color: white; border: 1px solid #444; margin: 10px 0; }
    </style>
</head>
<body class="in-menu">

    <div class="animated-bg"></div>

    <!-- Y√úKLENƒ∞YOR EKRANI -->
    <div id="loading-screen">
        <div class="loader"></div>
        <div>SUNUCUYA BAƒûLANIYOR...</div>
        <div style="font-size:14px; color:#666; margin-top:10px;">Verileriniz E≈üitleniyor</div>
    </div>

    <!-- ANA MEN√ú -->
    <div id="main-menu" class="menu-overlay hidden">
        <div class="menu-panel">
            <div class="stats-display">
                <div>REKOR: <span id="menu-high-score" style="color:var(--primary)">0</span></div>
                <div class="kp-text">KP: <span id="menu-kp">0</span></div>
            </div>
            <div class="menu-title">NEON<br><span>ARENA</span></div>
            
            <button class="menu-btn" onclick="window.game.checkPlay()">OYNA</button>
            <button class="menu-btn" onclick="window.game.openCharMenu()">KARAKTERLER</button>
            <button class="menu-btn" onclick="window.game.openSettings()">AYARLAR</button>
        </div>
        
        <div id="char-preview-container">
            <div id="preview-name">DOAF</div>
            <div style="font-size:20px; color:var(--primary);">DASH YETENEƒûƒ∞</div>
        </div>
    </div>

    <!-- KARAKTER MEN√úS√ú -->
    <div id="char-menu" class="hidden" style="position:absolute; top:0; left:0; width:100%; height:100%;">
        <div style="position:absolute; top:30px; right:40px; font-size:24px; font-weight:bold; color:var(--kp-color);">BAKƒ∞YE: <span id="char-menu-kp">0</span> KP</div>
        <div class="char-menu-layout" style="margin: 80px auto; height: 75%;">
            <div class="char-list-container" id="char-list"></div>
            <div class="char-details-container">
                <canvas id="char-preview-canvas" width="200" height="200"></canvas>
                <div id="detail-name">KARAKTER</div>
                <div id="detail-role">ROL</div>
                <div id="detail-desc">A√ßƒ±klama</div>
                <button id="action-btn" class="action-btn btn-select">SE√á</button>
            </div>
        </div>
        <button class="menu-btn" style="position:absolute; bottom:30px; left:40px; width:200px; text-align:center; background:rgba(0,0,0,0.8);" onclick="window.game.closeCharMenu()">GERƒ∞ D√ñN</button>
    </div>

    <!-- OYUN ARAY√úZ√ú -->
    <div id="game-ui">
        <div id="wave-text">WAVE 1</div>
        <div id="tactical-map">
            <div id="tactical-text">HEDEF SE√á<br><span style="font-size:20px; color:white;">KALAN: <span id="bombs-left">5</span></span></div>
        </div>

        <div id="boss-ui">
            <div style="color:#ff003c; font-weight:bold; font-size:24px; margin-bottom:5px; text-shadow:0 0 10px black;">‚ö†Ô∏è BOSS ‚ö†Ô∏è</div>
            <div id="boss-bar-bg"><div id="boss-bar"></div></div>
        </div>
        
        <div id="top-bar">
            <div>
                <div class="hud-box">WAVE <span id="wave-num" style="color:var(--primary)">1</span></div>
                <div class="kp-hud">+<span id="game-kp">0</span> KP</div>
            </div>
            <div style="text-align: right;">
                <div class="hud-box">SKOR: <span id="score">0</span></div>
                <div id="health-container"><div id="health-bar"></div></div>
            </div>
        </div>

        <div id="minimap-container">
            <canvas id="minimap-canvas" width="180" height="180"></canvas>
        </div>

        <div id="ui-layer">
            <div class="weapon-card active" onclick="window.game.switchWeapon(0)" id="w-0">üî´</div>
            <div class="weapon-card locked" onclick="window.game.switchWeapon(1)" id="w-1">üß®</div>
            <div class="weapon-card locked" onclick="window.game.switchWeapon(2)" id="w-2">üî•</div>
            <div class="weapon-card locked" onclick="window.game.switchWeapon(3)" id="w-3">üéØ</div>
        </div>

        <div id="skills-container">
            <div id="ability-icon">
                <span id="ability-symbol" style="font-size:30px; color:white; font-weight:bold;">E</span>
                <div id="ability-cooldown"></div>
            </div>
            <div id="ability-text">HAZIR</div>
        </div>
    </div>

    <!-- MODALLER -->
    <div id="settings-menu">
        <div class="settings-panel">
            <h2 style="font-size:40px; color:white; margin-bottom:30px;">AYARLAR</h2>
            <div style="margin-bottom:20px;">
                <label style="color:var(--primary); font-size:18px;">GRAFƒ∞K</label>
                <select onchange="window.game.setQuality(this.value)">
                    <option value="LOW">D√ú≈û√úK (Performans)</option>
                    <option value="MEDIUM">ORTA</option>
                    <option value="HIGH" selected>Y√úKSEK (Neon)</option>
                </select>
            </div>
            <div style="margin-bottom:20px;">
                <label style="color:var(--primary); font-size:18px;">HASSASƒ∞YET</label>
                <input type="range" min="0.01" max="0.2" step="0.01" value="0.08" oninput="window.game.setSensitivity(this.value)">
            </div>
            <button class="menu-btn" style="width:100%; text-align:center;" onclick="window.game.closeSettings()">KAPAT</button>
        </div>
    </div>

    <div id="level-up-screen">
        <h1 style="color:white; margin-bottom: 10px;">DALGA TAMAMLANDI</h1>
        <h2 style="color:var(--kp-color); margin-bottom: 30px;">KAZANILAN: <span id="wave-income">0</span> KP</h2>
        <div style="font-size: 18px; color: #aaa; margin-bottom: 20px;">Bir √∂d√ºl se√ß:</div>
        <div class="cards-container" id="upgrade-container" style="display:flex; flex-wrap:wrap; justify-content:center;"></div>
    </div>

    <div id="game-over">
        <h1 style="color:red; font-size:60px;">OYUN Bƒ∞TTƒ∞</h1>
        <p style="font-size:30px; color:white;">SKOR: <span id="final-score">0</span></p>
        <button class="menu-btn" style="text-align:center;" onclick="location.reload()">MEN√úYE D√ñN</button>
    </div>

    <div id="resume-modal" class="hidden">
        <div style="background:#111; border:2px solid var(--primary); padding:40px; text-align:center; border-radius:10px;">
            <h2 style="color:white; font-size:40px;">TEBRƒ∞KLER!</h2>
            <div style="color:#aaa; margin-bottom:20px;">Kayƒ±tlƒ± ilerleme bulundu: <b>Wave <span id="saved-wave-num">0</span></b><br>Se√ßimini yap:</div>
            <div style="display:flex; gap:20px; margin-top:30px; justify-content:center;">
                <button class="menu-btn" onclick="window.game.startGame(1); window.game.closeResume()">BA≈ûTAN BA≈ûLA<br><span style="font-size:14px; color:#888;">(Wave 1 - G√º√ßlenerek Git)</span></button>
                <button class="menu-btn" style="border-color:var(--kp-color);" onclick="window.game.resumeGame()">DEVAM ET<br><span style="font-size:14px; color:#888;">(Kaldƒ±ƒüƒ±n Yerden)</span></button>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script type="module">
// --- FIREBASE ENTEGRASYONU ---
import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
import { getFirestore, doc, setDoc, getDoc, collection, onSnapshot } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';

let db, auth, userId;
let saveTimeout;

// Buluta Kaydetme (Debounce: √áok sƒ±k yazmayƒ± √∂nler)
const saveToCloud = async (data) => {
    if (!db || !userId) return;
    clearTimeout(saveTimeout);
    saveTimeout = setTimeout(async () => {
        try {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default';
            const docRef = doc(db, 'artifacts', appId, 'users', userId, 'gamedata', 'save');
            await setDoc(docRef, data);
            console.log("Oyun buluta kaydedildi.");
        } catch(e) { console.error("Bulut kayƒ±t hatasƒ±:", e); }
    }, 2000); // 2 saniye gecikmeli kayƒ±t
};

const SaveSystem = {
    // Varsayƒ±lan Veri
    getDefaults: () => ({ kp: 0, hs: 0, ul: [0], sel: 0, maxW: 1 }),
    
    // Y√ºkleme ƒ∞≈ülemi (Hem Yerel Hem Bulut)
    init: async () => {
        let localData = SaveSystem.getDefaults();
        try { 
            localData = JSON.parse(localStorage.getItem('neon_arena_v6')) || localData; 
        } catch(e){}

        // Firebase Kontrol√º (Varsa baƒülan, yoksa yerel devam et)
        if (typeof __firebase_config !== 'undefined') {
            try {
                const app = initializeApp(JSON.parse(__firebase_config));
                auth = getAuth(app);
                db = getFirestore(app);
                
                await signInAnonymously(auth);
                userId = auth.currentUser.uid;
                
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default';
                const docRef = doc(db, 'artifacts', appId, 'users', userId, 'gamedata', 'save');
                const snap = await getDoc(docRef);
                
                if (snap.exists()) {
                    // Bulut verisi varsa ve daha yeniyse (basit√ße varlƒ±ƒüƒ±nƒ± kontrol ediyoruz, merge yapƒ±yoruz)
                    // Pratikte hangisi daha y√ºksek KP/Wave ise onu almak mantƒ±klƒ± ama ≈üimdilik bulut √∂ncelikli.
                    const cloudData = snap.data();
                    // Yerel ile birle≈ütir (Bulut baskƒ±n)
                    localData = { ...localData, ...cloudData };
                    // En iyi skorlarƒ± birle≈ütir
                    localData.hs = Math.max(localData.hs, cloudData.hs || 0);
                    localData.maxW = Math.max(localData.maxW, cloudData.maxW || 1);
                    localData.kp = Math.max(localData.kp, cloudData.kp || 0);
                }
            } catch (e) {
                console.log("Offline modda devam ediliyor.");
            }
        }
        return localData;
    },

    save: (d) => {
        // 1. Yerel Kayƒ±t (Hƒ±zlƒ±)
        localStorage.setItem('neon_arena_v6', JSON.stringify(d));
        // 2. Bulut Kayƒ±t (Arka Planda)
        saveToCloud(d);
    }
};

// --- OYUN KODLARI ---

class Particle {
    constructor(x, y, c, speed, life) {
        this.x = x; this.y = y; 
        this.c = c; this.l = life; this.maxL = life;
        const a = Math.random() * Math.PI * 2;
        const s = Math.random() * speed;
        this.vx = Math.cos(a) * s; this.vy = Math.sin(a) * s;
        this.size = Math.random() * 3 + 1;
    }
    update() { this.x += this.vx; this.y += this.vy; this.l--; this.vx *= 0.95; this.vy *= 0.95; }
    draw(ctx, cam) {
        ctx.globalAlpha = this.l / this.maxL; ctx.fillStyle = this.c;
        if(window.game.q === 'HIGH') { ctx.shadowBlur=10; ctx.shadowColor=this.c; }
        ctx.beginPath(); ctx.arc(this.x - cam.x, this.y - cam.y, this.size, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1; ctx.shadowBlur=0;
    }
}

class FloatingText {
    constructor(x, y, text, color) { this.x = x; this.y = y; this.t = text; this.c = color; this.l = 60; this.vy = -1; }
    update() { this.y += this.vy; this.l--; }
    draw(ctx, cam) {
        ctx.globalAlpha = this.l / 60; ctx.fillStyle = this.c; ctx.font = "bold 20px Rajdhani";
        if(window.game.q === 'HIGH') { ctx.shadowBlur=5; ctx.shadowColor=this.c; }
        ctx.fillText(this.t, this.x - cam.x, this.y - cam.y);
        ctx.globalAlpha = 1; ctx.shadowBlur=0;
    }
}

class Bullet {
    constructor(x, y, ang, type, dmg, isEn=false) {
        this.x = x; this.y = y; this.ang = ang; 
        this.type = type; 
        this.dmg = dmg; this.isEn = isEn;
        this.speed = isEn ? 7 : 25; 
        if(type === 10) this.speed = 6; 
        this.baseVx = Math.cos(ang) * this.speed; this.baseVy = Math.sin(ang) * this.speed;
        this.del = false; this.dist = 0; this.maxDist = type===10 ? 800 : 1500;
        this.isCrit = false;
    }
    update(walls, timeScale) {
        const f = this.isEn ? timeScale : 1;
        this.x += this.baseVx * f; this.y += this.baseVy * f;
        this.dist += this.speed * f;
        if(this.dist > this.maxDist) this.del = true;

        for(let w of walls) {
            if(checkRectCol({x:this.x-5, y:this.y-5, w:10, h:10}, w)) {
                this.del = true;
                if(this.type === 10) window.game.fx(this.x, this.y, '#bc13fe', 10);
                else window.game.fx(this.x, this.y, this.isEn?'#f00':'#0ff', 5);
                break;
            }
        }
    }
    draw(ctx, cam) {
        ctx.save(); ctx.translate(this.x - cam.x, this.y - cam.y); ctx.rotate(this.ang);
        
        if(this.type === 10) { 
            ctx.strokeStyle = '#bc13fe'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(0,0, 20, -0.5, 0.5); ctx.stroke();
        } else if(this.isEn) {
            ctx.fillStyle = '#ff003c';
            if(window.game.q === 'HIGH') { ctx.shadowBlur = 15; ctx.shadowColor = 'red'; }
            ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.fill();
        } else {
            ctx.fillStyle = this.isCrit ? '#ffff00' : (this.type === 2 ? '#ffaa00' : '#00f3ff');
            if(window.game.q === 'HIGH') { ctx.shadowBlur = 15; ctx.shadowColor = ctx.fillStyle; }
            const w = this.type === 3 ? 40 : 20;
            ctx.fillRect(-w/2, -2, w, 4);
        }
        ctx.restore(); ctx.shadowBlur=0;
    }
}

class Enemy {
    constructor(x, y, wave, type) {
        this.x = x; this.y = y; this.type = type; 
        
        if(type === 2) { // Boss
            this.r = 60; this.maxHp = 3000 * (1 + wave*0.5); 
            this.speed = 1.5; this.color = '#bc13fe';
        } else if(type === 1) { 
            this.r = 15; this.maxHp = 30 * wave; this.speed = 0; this.color = '#ffff00';
        } else { 
            this.r = 20; this.maxHp = 80 * (wave>10?wave:wave*0.8); this.speed = 2.8; this.color = '#ff003c';
        }
        
        this.hp = this.maxHp; this.vx = 0; this.vy = 0; this.lastShot = 0; this.lastSpecial = 0;
        this.dead = false; // √áifte √∂l√ºm√º engellemek i√ßin
    }

    canSeePlayer(player, walls) {
        const dist = Math.hypot(player.x - this.x, player.y - this.y);
        if(dist > 1000) return false; 
        const dx = player.x - this.x, dy = player.y - this.y;
        const steps = dist / 20;
        for(let i=1; i<steps; i++) {
            const cx = this.x + (dx * (i/steps));
            const cy = this.y + (dy * (i/steps));
            for(let w of walls) {
                if(checkRectCol({x:cx,y:cy,w:1,h:1}, w)) return false;
            }
        }
        return true;
    }

    update(player, walls, game) {
        const timeScale = game.timeScale; 
        const ang = Math.atan2(player.y - this.y, player.x - this.x);
        let move = true;

        if(this.type === 2) {
            const see = this.canSeePlayer(player, walls);
            if(see) {
                move = false; 
                if(Date.now() - this.lastShot > 500/timeScale) {
                    game.bullets.push(new Bullet(this.x, this.y, ang, 0, 20, true));
                    this.lastShot = Date.now();
                }
            } else { move = true; }

            if(Date.now() - this.lastSpecial > 10000/timeScale) {
                for(let i=-1; i<=1; i+=0.5) {
                    game.bullets.push(new Bullet(this.x, this.y, ang + i, 10, 40, true));
                }
                this.lastSpecial = Date.now();
                window.game.txt(this.x, this.y, "Dƒ∞KKAT!", "#bc13fe");
            }
        }

        if(this.speed > 0 && move) {
            const currentSpeed = this.speed * timeScale;
            this.vx = Math.cos(ang) * currentSpeed; this.vy = Math.sin(ang) * currentSpeed;
            
            game.enemies.forEach(e => {
                if(e === this) return;
                if(Math.hypot(e.x - this.x, e.y - this.y) < this.r + e.r) {
                    const pa = Math.atan2(this.y - e.y, this.x - e.x);
                    this.vx += Math.cos(pa)*timeScale; this.vy += Math.sin(pa)*timeScale;
                }
            });

            let nx = this.x + this.vx; let ny = this.y + this.vy;
            let colX = false, colY = false;
            for(let w of walls) {
                if(checkRectCol({x:nx-this.r, y:this.y-this.r, w:this.r*2, h:this.r*2}, w)) colX = true;
                if(checkRectCol({x:this.x-this.r, y:ny-this.r, w:this.r*2, h:this.r*2}, w)) colY = true;
            }
            if(!colX) this.x = nx; if(!colY) this.y = ny;
        }

        if(this.type === 1) {
            if(Date.now() - this.lastShot > 2000/timeScale) {
                game.bullets.push(new Bullet(this.x, this.y, ang, 0, 10, true));
                this.lastShot = Date.now();
            }
        }
    }

    draw(ctx, cam, quality) {
        const scrX = this.x - cam.x; const scrY = this.y - cam.y;
        if(scrX<-100||scrX>canvas.width+100||scrY<-100||scrY>canvas.height+100) return;

        ctx.save(); ctx.translate(scrX, scrY);
        if(quality === 'HIGH') { ctx.shadowBlur = 20; ctx.shadowColor = this.color; }
        ctx.fillStyle = this.color;
        
        if(this.type === 2) { 
            ctx.fillRect(-this.r, -this.r, this.r*2, this.r*2);
            ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.strokeRect(-this.r, -this.r, this.r*2, this.r*2);
        } else if (this.type === 1) { 
            ctx.beginPath(); ctx.moveTo(15,0); ctx.lineTo(-10,10); ctx.lineTo(-10,-10); ctx.fill();
        } else {
            ctx.beginPath(); ctx.arc(0, 0, this.r, 0, Math.PI*2); ctx.fill();
        }
        ctx.shadowBlur = 0;
        const hpPer = this.hp / this.maxHp;
        ctx.fillStyle = 'red'; ctx.fillRect(-20, -this.r - 15, 40, 5);
        ctx.fillStyle = '#0f0'; ctx.fillRect(-20, -this.r - 15, 40 * hpPer, 5);
        ctx.restore();
    }
}

const CHARACTERS = [
    { id: 0, name: "DOAF", color: "#00f3ff", price: 0, role: "Hƒ±z", desc: "E: Dash. Kƒ±sa mesafe ileri atƒ±lƒ±r. (4sn CD)", ability: "DASH" },
    { id: 1, name: "TOGP", color: "#2ecc71", price: 120, role: "I≈üƒ±nlanma", desc: "E: ƒ∞≈üaret bƒ±rak/D√∂n. (1sn CD)", ability: "TP" },
    { id: 2, name: "SAM", color: "#e74c3c", price: 250, role: "Tank", desc: "E: √ñfke Modu. B√ºy√ºr ve g√º√ßlenir. (30sn CD)", ability: "RAGE" },
    { id: 3, name: "VLEX", color: "#9b59b6", price: 350, role: "Taktik", desc: "E: Hava Saldƒ±rƒ±sƒ±. (15sn CD)", ability: "AIR" },
    { id: 4, name: "GOFER", color: "#f1c40f", price: 550, role: "Suikast", desc: "E: Hayalet. G√∂r√ºnmezlik.", ability: "GHOST" },
    { id: 5, name: "LMAY", color: "#ff8800", price: 680, role: "Zaman", desc: "E: Time Warp. D√º≈ümanlarƒ± yava≈ülatƒ±r. (35sn CD)", ability: "TIME" },
    { id: 6, name: "TKAR", color: "#ffffff", price: 750, role: "Destek", desc: "E: Drone ≈ûoku. √áevredeki d√º≈ümanlarƒ±n canƒ±nƒ± %50 alƒ±r. (16sn CD)", ability: "DRONE" }
];

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth; canvas.height = window.innerHeight;

const keys = { w:false, a:false, s:false, d:false, e:false };
const mouse = { x:0, y:0, down:false };

window.addEventListener('keydown', e => { 
    if(keys.hasOwnProperty(e.key)) keys[e.key]=true; 
    if(['1','2','3','4'].includes(e.key) && window.game && window.game.state==='PLAYING') window.game.switchWeapon(parseInt(e.key)-1); 
    if(e.key === 'Escape' && window.game && window.game.state === 'PLAYING') window.game.openSettings();
});
window.addEventListener('keyup', e => { 
    if(keys.hasOwnProperty(e.key)) keys[e.key]=false; 
    if(e.key.toLowerCase()=='e' && window.game && window.game.state=='PLAYING') window.game.player.useAbility(); 
});
window.addEventListener('mousemove', e => { mouse.x=e.clientX; mouse.y=e.clientY; });
window.addEventListener('mousedown', () => { mouse.down=true; if(window.game && window.game.state === 'TACTICAL') window.game.player.handleAirClick(); });
window.addEventListener('mouseup', () => mouse.down=false);
window.addEventListener('resize', () => { canvas.width=window.innerWidth; canvas.height=window.innerHeight; });

function checkRectCol(r1, r2) { return r1.x < r2.x+r2.w && r1.x+r1.w > r2.x && r1.y < r2.y+r2.h && r1.y+r1.h > r2.y; }
function checkCircCol(c1, c2) { return Math.hypot(c1.x-c2.x, c1.y-c2.y) < c1.r+c2.r; }

class Minimap {
    constructor() { this.canvas = document.getElementById('minimap-canvas'); this.ctx = this.canvas.getContext('2d'); }
    draw(player, enemies, walls, worldW, worldH) {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = 'rgba(0, 20, 40, 0.8)'; this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);
        const scale = Math.min(this.canvas.width / worldW, this.canvas.height / worldH);
        const offX = (this.canvas.width - worldW*scale)/2; 
        const offY = (this.canvas.height - worldH*scale)/2;

        walls.forEach(w => { 
            this.ctx.fillStyle = w.color || '#666'; 
            this.ctx.fillRect(offX + w.x * scale, offY + w.y * scale, w.w * scale, w.h * scale); 
        });
        enemies.forEach(e => {
            this.ctx.fillStyle = e.type === 2 ? '#bc13fe' : '#ff003c';
            const s = e.type === 2 ? 6 : 3;
            this.ctx.fillRect(offX + e.x * scale - s/2, offY + e.y * scale - s/2, s, s);
        });
        this.ctx.fillStyle = '#00f3ff'; this.ctx.beginPath(); 
        this.ctx.arc(offX + player.x * scale, offY + player.y * scale, 3, 0, Math.PI*2); this.ctx.fill();
    }
}

class Player {
    constructor() {
        this.x=1500; this.y=1500; this.r=20; this.speed=4.5; this.baseSpeed=4.5;
        this.hp=100; this.maxHp=100; this.ang=0; this.weap=0; this.lastShot=0;
        this.unlockedWeaps=[true,false,false,false]; this.charId=0; this.abCd=4000; this.lastAb=0;
        this.dashing=false; this.tpMarker=null; this.rage=false; this.ghost=false; this.bombs=0; this.timeWarp=false;
        this.dmgMult=1;
    }
    loadChar(id) {
        this.charId=id; this.baseSpeed=4.5; this.r=20;
        if(id==0) this.abCd=4000; 
        if(id==1) { this.abCd=1000; this.tpMarker=null; }
        if(id==2) { this.abCd=30000; this.rage=false; } 
        if(id==3) this.abCd=15000;
        if(id==4) { this.abCd=20000; this.ghost=false; }
        if(id==5) { this.abCd=35000; this.timeWarp=false; } 
        if(id==6) { this.abCd=16000; } 
    }
    useAbility() {
        const now=Date.now();
        if(this.charId==1) { 
            if(!this.tpMarker) { this.tpMarker={x:this.x,y:this.y}; } 
            else { window.game.fx(this.x, this.y, '#2ecc71', 10); this.x=this.tpMarker.x; this.y=this.tpMarker.y; this.tpMarker=null; this.lastAb=now; window.game.fx(this.x, this.y, '#2ecc71', 10); } return; 
        }
        if(this.charId==3 && now-this.lastAb > this.abCd) { 
            if(window.game.state==='PLAYING') { window.game.state='TACTICAL'; this.bombs=5; document.getElementById('tactical-map').style.display='block'; document.getElementById('bombs-left').innerText=5; } return;
        }
        if(now-this.lastAb < this.abCd) return;
        this.lastAb=now;

        if(this.charId==0) { this.dashing=true; this.speed=20; window.game.fx(this.x, this.y, '#00f3ff', 15); setTimeout(()=>this.dashing=false, 150); }
        if(this.charId==2) { this.rage=true; this.r=35; this.baseSpeed=7; this.dmgMult=2; window.game.fx(this.x, this.y, '#ff0000', 30); setTimeout(()=>{this.rage=false;this.r=20;this.baseSpeed=4.5;this.dmgMult=1;},10000); }
        if(this.charId==4) { this.ghost=true; this.baseSpeed=7; setTimeout(()=>this.ghost=false,10000); }
        if(this.charId==5) { this.timeWarp=true; window.game.timeScale = 0.2; this.baseSpeed = 8; this.dmgMult = 2; window.game.txt(this.x, this.y, "TIME WARP!", "#ff8800"); setTimeout(()=>{this.timeWarp=false; window.game.timeScale = 1; this.baseSpeed = 4.5; this.dmgMult = 1;}, 10000); }
        if(this.charId==6) { 
            window.game.fx(this.x, this.y, '#ffffff', 20);
            window.game.enemies.forEach(e => {
                if(Math.hypot(e.x - this.x, e.y - this.y) < 400) {
                    e.hp -= e.maxHp * 0.5; 
                    window.game.fx(e.x, e.y, '#fff', 10);
                    window.game.txt(e.x, e.y, "SHOCK!", "white");
                    if(e.hp<=0 && !e.dead) { e.dead=true; window.game.killEnemy(e); }
                }
            });
        }
    }
    handleAirClick() {
        if(this.bombs>0) {
            this.bombs--; document.getElementById('bombs-left').innerText = this.bombs;
            const wx = mouse.x + window.game.cam.x; const wy = mouse.y + window.game.cam.y;
            window.game.fx(wx, wy, '#ffaa00', 20);
            window.game.enemies.forEach(e=>{ 
                if(Math.hypot(e.x-wx, e.y-wy)<250) { 
                    e.hp-=1000; window.game.txt(e.x, e.y, "BOOM!", "orange"); 
                    if(e.hp<=0 && !e.dead) { e.dead=true; window.game.killEnemy(e); } 
                } 
            });
            if(this.bombs<=0) setTimeout(()=>{ window.game.state='PLAYING'; document.getElementById('tactical-map').style.display='none'; this.lastAb=Date.now(); }, 500);
        }
    }
    update(walls, cam, wW, wH) {
        let dx=0, dy=0; if(keys.w) dy=-1; if(keys.s) dy=1; if(keys.a) dx=-1; if(keys.d) dx=1;
        this.speed = this.ghost?7:(this.rage?7:(this.dashing?20:(this.timeWarp?8:this.baseSpeed)));
        if(dx!=0 || dy!=0) {
            const l=Math.hypot(dx,dy); dx/=l; dy/=l;
            let nx=this.x+dx*this.speed; let cx=false; for(let w of walls) if(checkRectCol({x:nx-this.r,y:this.y-this.r,w:this.r*2,h:this.r*2},w)) cx=true;
            if(!cx && nx>20 && nx<wW-20) this.x=nx;
            let ny=this.y+dy*this.speed; let cy=false; for(let w of walls) if(checkRectCol({x:this.x-this.r,y:ny-this.r,w:this.r*2,h:this.r*2},w)) cy=true;
            if(!cy && ny>20 && ny<wH-20) this.y=ny;
        }
        this.ang = Math.atan2(mouse.y-(this.y-cam.y), mouse.x-(this.x-cam.x));
        const now=Date.now(); let cd = this.charId==1 && !this.tpMarker ? 0 : Math.max(0, (this.abCd-(now-this.lastAb))/this.abCd);
        document.getElementById('ability-cooldown').style.height = (cd*100)+'%';
        document.getElementById('ability-text').innerText = cd>0 ? Math.ceil(cd*this.abCd/1000)+"s" : (this.charId==1&&this.tpMarker?"D√ñN":"HAZIR");
    }
    draw(ctx, cam) {
        let dx, dy; if(window.game.state==='MENU') { dx=canvas.width*0.75; dy=canvas.height*0.5; this.ang+=0.02; } else { dx=this.x-cam.x; dy=this.y-cam.y; }
        ctx.save(); ctx.translate(dx,dy);
        if(this.tpMarker && window.game.state==='PLAYING') { ctx.save(); ctx.translate(-dx,-dy); ctx.strokeStyle='rgba(0,255,0,0.3)'; ctx.lineWidth=2; ctx.setLineDash([10,10]); ctx.beginPath(); ctx.moveTo(dx,dy); ctx.lineTo(this.tpMarker.x-cam.x, this.tpMarker.y-cam.y); ctx.stroke(); ctx.restore(); }
        if(this.ghost) ctx.globalAlpha=0.3;
        ctx.rotate(this.ang); const c=CHARACTERS[this.charId].color; 
        if(window.game.q === 'HIGH') { ctx.shadowBlur=20; ctx.shadowColor=c; } ctx.fillStyle=c;
        if(this.charId==6) { 
            ctx.fillRect(-15,-15,30,30); ctx.fillStyle='#aaa'; ctx.fillRect(15,-5,10,10); ctx.fillRect(-25,-5,10,10);
        } else {
            if(this.charId==0) ctx.fillRect(-20,-15,40,30);
            else if(this.charId==1) { ctx.beginPath(); ctx.moveTo(20,0); ctx.lineTo(-20,20); ctx.lineTo(-20,-20); ctx.fill(); }
            else if(this.charId==2) { const s=this.rage?40:30; ctx.fillRect(-s/2,-s/2,s,s); }
            else if(this.charId==3) { ctx.beginPath(); ctx.moveTo(0,-25); ctx.lineTo(20,0); ctx.lineTo(0,25); ctx.lineTo(-20,0); ctx.fill(); }
            else if(this.charId==4) { ctx.beginPath(); ctx.moveTo(25,0); ctx.lineTo(-15,10); ctx.lineTo(-15,-10); ctx.fill(); }
            else if(this.charId==5) { ctx.beginPath(); ctx.moveTo(-20,-20); ctx.lineTo(20,-20); ctx.lineTo(-20,20); ctx.lineTo(20,20); ctx.fill(); }
        }
        ctx.fillStyle='#fff'; ctx.shadowBlur=0; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#333'; ctx.fillRect(10,-5,35,10);
        ctx.restore(); ctx.globalAlpha=1; ctx.shadowBlur=0;
        if(this.tpMarker && window.game.state==='PLAYING') { const mx=this.tpMarker.x-cam.x, my=this.tpMarker.y-cam.y; ctx.strokeStyle='#0f0'; ctx.beginPath(); ctx.arc(mx,my,10,0,Math.PI*2); ctx.stroke(); ctx.fillStyle='#0f0'; ctx.fillText("TP", mx-10, my-15); }
        if(this.charId==6) { 
             const rot = Date.now()*0.005;
             ctx.fillStyle='#fff'; ctx.fillRect(dx+Math.cos(rot)*40, dy+Math.sin(rot)*40, 5, 5);
        }
    }
    drawPreview(ctx, id) {
        ctx.clearRect(0,0,200,200); ctx.save(); ctx.translate(100,100); ctx.rotate(Date.now()*0.002); ctx.scale(2,2);
        const c=CHARACTERS[id].color; ctx.shadowBlur=20; ctx.shadowColor=c; ctx.fillStyle=c;
        if(id==0) ctx.fillRect(-20,-15,40,30);
        else if(id==1) { ctx.beginPath(); ctx.moveTo(20,0); ctx.lineTo(-20,20); ctx.lineTo(-20,-20); ctx.fill(); }
        else if(id==2) ctx.fillRect(-15,-15,30,30);
        else if(id==3) { ctx.beginPath(); ctx.moveTo(0,-25); ctx.lineTo(20,0); ctx.lineTo(0,25); ctx.lineTo(-20,0); ctx.fill(); }
        else if(id==4) { ctx.beginPath(); ctx.moveTo(25,0); ctx.lineTo(-15,10); ctx.lineTo(-15,-10); ctx.fill(); }
        else if(id==5) { ctx.beginPath(); ctx.moveTo(-20,-20); ctx.lineTo(20,-20); ctx.lineTo(-20,20); ctx.lineTo(20,20); ctx.fill(); }
        else if(id==6) { ctx.fillRect(-15,-15,30,30); ctx.fillStyle='#aaa'; ctx.fillRect(15,-5,10,10); ctx.fillRect(-25,-5,10,10); }
        ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#333'; ctx.fillRect(10,-5,35,10);
        ctx.restore();
    }
}

class Game {
    constructor() {
        this.state='LOADING'; // Ba≈ülangƒ±√ßta y√ºkleniyor modu
        this.q='HIGH'; this.timeScale = 1.0;
        this.gameKp = 0;

        // Veriyi Y√ºkle ve Oyunu Ba≈ülat
        SaveSystem.init().then(data => {
            this.data = data;
            if(!this.data.maxW) this.data.maxW=1;
            
            document.getElementById('menu-high-score').innerText=this.data.hs;
            document.getElementById('menu-kp').innerText=this.data.kp;
            document.getElementById('char-menu-kp').innerText=this.data.kp;
            
            this.cam={x:0,y:0}; this.player=new Player(); this.player.loadChar(this.data.sel);
            this.minimap = new Minimap();
            this.prevCv = document.getElementById('char-preview-canvas');
            this.prevCtx = this.prevCv.getContext('2d');
            this.prevId = this.data.sel;
            
            this.wW=3000; this.wH=3000;
            this.walls=[]; this.bullets=[]; this.enemies=[]; this.parts=[]; this.txts=[];

            // Y√ºkleme ekranƒ±nƒ± gizle, men√ºy√º g√∂ster
            document.getElementById('loading-screen').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
            this.state = 'MENU';
        });
    }

    fx(x, y, c, n) { if(this.q!=='LOW') for(let i=0;i<n;i++) this.parts.push(new Particle(x,y,c,5,30)); }
    txt(x, y, t, c) { this.txts.push(new FloatingText(x,y,t,c)); }
    addScore(s) { this.score += s; document.getElementById('score').innerText = this.score; }
    
    // KP Ekleme (Oyun i√ßi + Kayƒ±t)
    addKp(k) { 
        this.gameKp += k; 
        this.data.kp += k; 
        document.getElementById('game-kp').innerText = this.gameKp; 
        SaveSystem.save(this.data); // Bulut kayƒ±t tetiklenir
    }

    // D√º≈üman √ñld√ºrme (Skor + KP)
    killEnemy(e) {
        const points = e.type===2 ? 1000 : 20;
        this.addScore(points);
        this.fx(e.x, e.y, e.color, 20);
        
        // ≈ûans eseri KP d√º≈ümesi
        const dropChance = e.type===2 ? 1 : 0.3; // Boss %100, Normal %30
        if(Math.random() < dropChance) {
            const amount = e.type===2 ? 100 : Math.floor(Math.random()*5)+1;
            this.addKp(amount);
            this.txt(e.x, e.y, `+${amount} KP`, '#ffd700');
        }
    }

    checkPlay() {
        if(this.data.maxW >= 10) {
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('resume-modal').classList.remove('hidden');
            document.getElementById('resume-modal').style.display='flex';
            document.getElementById('saved-wave-num').innerText = this.data.maxW;
        } else { this.startGame(1); }
    }
    closeResume() { document.getElementById('resume-modal').classList.add('hidden'); document.getElementById('resume-modal').style.display='none'; }
    resumeGame() { this.closeResume(); this.startGame(this.data.maxW); }

    openCharMenu() { this.state='CHAR_MENU'; document.getElementById('main-menu').classList.add('hidden'); document.getElementById('char-menu').classList.remove('hidden'); this.prevId = this.data.sel; this.renderCharList(); this.updateCharUI(); }
    closeCharMenu() { this.player.loadChar(this.data.sel); this.state='MENU'; document.getElementById('char-menu').classList.add('hidden'); document.getElementById('main-menu').classList.remove('hidden'); }
    renderCharList() {
        const l=document.getElementById('char-list'); l.innerHTML='';
        CHARACTERS.forEach((c,i)=>{
            const u=this.data.ul.includes(i), s=this.data.sel==i, a=this.prevId==i;
            const d=document.createElement('div'); d.className=`char-list-item ${a?'active':''} ${!u?'locked':''}`;
            d.innerHTML=`<div class="item-name" style="color:${c.color}">${c.name}</div><div class="item-role">${u?(s?'SE√áƒ∞Lƒ∞':'A√áIK'):c.price+' KP'}</div>`;
            d.onclick=()=>{ this.prevId=i; this.updateCharUI(); this.renderCharList(); };
            l.appendChild(d);
        });
    }
    updateCharUI() {
        const c=CHARACTERS[this.prevId], u=this.data.ul.includes(this.prevId);
        document.getElementById('detail-name').innerText=c.name; document.getElementById('detail-name').style.color=c.color;
        document.getElementById('detail-role').innerText=c.role; document.getElementById('detail-desc').innerText=c.desc;
        const b=document.getElementById('action-btn'); b.className='action-btn'; b.onclick=null;
        if(u) {
            if(this.data.sel==this.prevId) { b.innerText="SE√áƒ∞Lƒ∞"; b.classList.add('btn-locked'); }
            else {
                b.innerText="SE√á"; b.classList.add('btn-select');
                b.onclick=()=>{ this.data.sel=this.prevId; this.player.loadChar(this.prevId); SaveSystem.save(this.data); this.renderCharList(); this.updateCharUI(); }
            }
        } else {
            b.innerText=c.price+" KP AL";
            if(this.data.kp>=c.price) {
                b.classList.add('btn-buy');
                b.onclick=()=>{ this.data.kp-=c.price; this.data.ul.push(this.prevId); this.data.sel=this.prevId; this.player.loadChar(this.prevId); SaveSystem.save(this.data); document.getElementById('char-menu-kp').innerText=this.data.kp; this.renderCharList(); this.updateCharUI(); }
            } else { b.classList.add('btn-locked'); }
        }
    }

    openSettings() { if(this.state === 'PLAYING') { document.getElementById('settings-menu').style.display='flex'; } else { document.getElementById('main-menu').classList.add('hidden'); document.getElementById('settings-menu').style.display='flex'; } }
    closeSettings() { document.getElementById('settings-menu').style.display='none'; if(this.state !== 'PLAYING') document.getElementById('main-menu').classList.remove('hidden'); }
    setQuality(v) { this.q=v; } setSensitivity(v) { this.cam.sensitivity=parseFloat(v); }

    startGame(wv) {
        this.state='PLAYING'; 
        document.getElementById('main-menu').classList.add('hidden'); 
        document.getElementById('game-ui').style.display='block';
        document.body.classList.remove('in-menu');
        
        this.score=0; this.wave=0; this.gameKp=0; document.getElementById('game-kp').innerText=0;
        this.player.hp=100; this.player.x=1500; this.player.y=1500; this.timeScale=1.0;
        this.bullets=[]; this.enemies=[]; this.walls=[];
        
        this.wW = 3000; this.wH = 3000;
        this.initWalls();
        
        if(wv >= 10) {
            const expansions = Math.floor(wv / 10);
            for(let i=0; i<expansions; i++) this.expandMap(true);
        }

        this.startWave(wv);
    }

    initWalls() {
        this.walls=[ {x:-50,y:-50,w:this.wW+100,h:50}, {x:-50,y:this.wH,w:this.wW+100,h:50}, {x:-50,y:0,w:50,h:this.wH}, {x:this.wW,y:0,w:50,h:this.wH} ];
        for(let i=0;i<30;i++) {
            let w=100+Math.random()*200, h=100+Math.random()*200;
            let x=200+Math.random()*(this.wW-400), y=200+Math.random()*(this.wH-400);
            if(Math.hypot(x-this.player.x, y-this.player.y)>500) this.walls.push({x,y,w,h, color: '#00f3ff'});
        }
    }

    expandMap(silent=false) {
        const oldW = this.wW, oldH = this.wH;
        const add = 1000;
        this.wW += add*2; this.wH += add*2;
        
        this.walls[0].w = this.wW+100; 
        this.walls[1].y = this.wH; this.walls[1].w = this.wW+100; 
        this.walls[2].h = this.wH; 
        this.walls[3].x = this.wW; this.walls[3].h = this.wH; 

        const themeColors = ['#bc13fe', '#ffff00', '#00ff00', '#ff003c'];
        const theme = themeColors[Math.floor(Math.random()*themeColors.length)];

        if(!silent) this.txt(this.player.x, this.player.y, "HARƒ∞TA GENƒ∞≈ûLETƒ∞LDƒ∞!", theme);

        for(let i=0; i<15; i++) {
            let w=100+Math.random()*200, h=100+Math.random()*200;
            let isH = Math.random() > 0.5;
            let x,y;
            if(isH) {
                x = Math.random() * this.wW;
                y = Math.random() > 0.5 ? Math.random()*add : oldH + Math.random()*add;
            } else {
                x = Math.random() > 0.5 ? Math.random()*add : oldW + Math.random()*add;
                y = Math.random() * this.wH;
            }
            this.walls.push({x,y,w,h, color: theme});
        }
    }

    startWave(n) {
        this.wave=n; 
        if(n>this.data.maxW) { this.data.maxW=n; SaveSystem.save(this.data); }
        document.getElementById('wave-num').innerText=n; 
        const t=document.getElementById('wave-text'); t.innerText="WAVE "+n; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),2500);
        this.enemiesLeft = n%10==0 ? 1 : (3 + Math.floor(n * 1.2)); 
        document.getElementById('boss-ui').style.display = n%10==0 ? 'block' : 'none';

        if(n > 1 && n % 10 === 0) this.expandMap();
    }

    spawnEnemy() {
        let x, y, ok=false, t=0;
        while(!ok && t<50) {
            const a=Math.random()*Math.PI*2, d=800+Math.random()*400; 
            x=this.player.x+Math.cos(a)*d; y=this.player.y+Math.sin(a)*d;
            x=Math.max(100,Math.min(x,this.wW-100)); y=Math.max(100,Math.min(y,this.wH-100));
            ok=true; for(let w of this.walls) if(checkRectCol({x:x-30,y:y-30,w:60,h:60},w)) ok=false;
            t++;
        }
        if(!ok) { x=100; y=100; } 

        let type = 0;
        if(this.wave % 10 == 0 && this.enemies.filter(e=>e.type==2).length==0) type=2; 
        else if(this.wave > 5 && Math.random() < 0.15) type=1; 
        this.enemies.push(new Enemy(x, y, this.wave, type));
    }

    switchWeapon(i) {
        if(!this.player.unlockedWeaps[i]) return;
        this.player.weap=i;
        document.querySelectorAll('.weapon-card').forEach((e,ix)=>e.classList.toggle('active', ix===i));
    }

    update() {
        // STATE LOADING CHECK
        if (this.state === 'LOADING') return;

        if(this.state!=='PLAYING' && this.state!=='TACTICAL') return;

        this.cam.x += (this.player.x - canvas.width/2 - this.cam.x) * 0.1;
        this.cam.y += (this.player.y - canvas.height/2 - this.cam.y) * 0.1;
        
        this.player.update(this.walls, this.cam, this.wW, this.wH);

        if(mouse.down && this.state === 'PLAYING') {
            const now=Date.now(); 
            const rates=[400,800,100,1500]; 
            let r=rates[this.player.weap]; if(this.player.rage) r/=2;
            if(this.player.timeWarp) r /= 1.5;

            if(now-this.player.lastShot>r) {
                let dmg=[25,15,10,200][this.player.weap]*this.player.dmgMult;
                const ang = this.player.ang;
                let isCrit = false;

                if(this.player.weap === 3) {
                    const mx = mouse.x + this.cam.x; const my = mouse.y + this.cam.y;
                    for(let e of this.enemies) {
                        if(Math.hypot(e.x - mx, e.y - my) < e.r + 10) {
                            isCrit = true; dmg *= 1.5;
                            this.txt(this.player.x, this.player.y - 50, "CRIT!", "yellow");
                            break;
                        }
                    }
                }

                const b = new Bullet(this.player.x, this.player.y, ang, this.player.weap, dmg);
                if(isCrit) b.isCrit = true;

                if(this.player.weap==1) { // Shotgun
                    for(let i=-2;i<=2;i++) this.bullets.push(new Bullet(this.player.x,this.player.y,ang+i*0.15,1,dmg));
                } else if(this.player.weap==2) { // SMG
                    const spr = (Math.random()-0.5)*0.2;
                    this.bullets.push(new Bullet(this.player.x,this.player.y,ang+spr,2,dmg));
                } else { 
                    this.bullets.push(b);
                }
                this.player.lastShot=now;
            }
        }

        this.bullets.forEach(b=>b.update(this.walls, this.timeScale)); 
        this.bullets=this.bullets.filter(b=>!b.del);

        this.enemies.forEach(e=>{
            e.update(this.player, this.walls, this);
            if(e.type==2) document.getElementById('boss-bar').style.width=(Math.max(0,e.hp)/e.maxHp*100)+'%';
            
            if(Math.hypot(e.x-this.player.x, e.y-this.player.y) < e.r+20 && !this.player.ghost) {
                this.player.hp -= 0.5; 
                if(this.player.hp<=0) this.gameOver();
            }
            if(this.player.ghost && Math.hypot(e.x-this.player.x, e.y-this.player.y)<50) {
                e.hp-=2; this.fx(e.x, e.y, '#fff', 1);
            }
        });

        this.bullets.forEach(b=>{
            if(b.isEn) {
                if(checkCircCol({x:b.x,y:b.y,r:5}, {x:this.player.x, y:this.player.y, r:20}) && !b.del && !this.player.ghost) {
                    this.player.hp-=b.dmg; b.del=true; 
                    this.fx(this.player.x, this.player.y, '#f00', 5);
                    this.txt(this.player.x, this.player.y, "-"+b.dmg, "red");
                    if(this.player.hp<=0) this.gameOver("MERMƒ∞");
                }
            } else {
                this.enemies.forEach(e=>{
                    if(checkCircCol({x:b.x,y:b.y,r:5}, {x:e.x, y:e.y, r:e.r}) && !b.del) {
                        e.hp-=b.dmg; b.del=true; 
                        this.fx(b.x, b.y, b.isCrit ? '#ff0' : (b.type==2?'#ffaa00':'#0ff'), 3);
                        this.txt(e.x, e.y, Math.floor(b.dmg), b.isCrit ? "#ff0" : "#fff");
                        
                        if(e.hp<=0 && !e.dead) {
                            e.dead = true;
                            this.killEnemy(e);
                        }
                    }
                });
            }
        });

        this.enemies=this.enemies.filter(e=>e.hp>0);
        if(this.enemiesLeft>0) { 
            if(this.enemies.length < 15 && Math.random()<0.05) { this.spawnEnemy(); this.enemiesLeft--; } 
        } else if(this.enemies.length==0 && this.state === 'PLAYING') { this.levelUp(); }

        this.parts.forEach(p=>p.update()); this.parts=this.parts.filter(p=>p.l>0);
        this.txts.forEach(t=>t.update()); this.txts=this.txts.filter(t=>t.l>0);
        document.getElementById('health-bar').style.width=Math.max(0, (this.player.hp/this.player.maxHp*100))+'%';
    }

    levelUp() {
        this.state='LEVELUP';
        const inc = 50 + (this.wave * 10); 
        this.addKp(inc);
        document.getElementById('wave-income').innerText = inc;
        const s=document.getElementById('level-up-screen');
        const c=document.getElementById('upgrade-container'); c.innerHTML='';
        
        const allOptions=[
            {t:'CAN YENƒ∞LE',i:'‚ù§Ô∏è',desc:'Mevcut canƒ±nƒ± +50 yeniler.',f:()=>{game.player.hp=Math.min(100,game.player.hp+50)}},
            {t:'HASAR ARTIR',i:'‚ö°',desc:'T√ºm silahlarƒ±n hasarƒ±nƒ± %20 artƒ±rƒ±r.',f:()=>{game.player.dmgMult+=0.2}},
            {t:'HIZ ARTIR',i:'üëü',desc:'Hareket hƒ±zƒ±nƒ± %10 artƒ±rƒ±r.',f:()=>{game.player.baseSpeed+=0.5}} 
        ];
        if(!this.player.unlockedWeaps[1]) allOptions.push({t:'POMPALI T√úFEK',i:'üß®',desc:'Yakƒ±n mesafe, √ßoklu atƒ±≈ü.',f:()=>{game.player.unlockedWeaps[1]=true; document.getElementById('w-1').classList.remove('locked');}});
        if(!this.player.unlockedWeaps[2]) allOptions.push({t:'MAKƒ∞NELƒ∞ T√úFEK',i:'üî•',desc:'Seri atƒ±≈ü yapan silah.',f:()=>{game.player.unlockedWeaps[2]=true; document.getElementById('w-2').classList.remove('locked');}});
        if(!this.player.unlockedWeaps[3]) allOptions.push({t:'SNIPER',i:'üéØ',desc:'Y√ºksek hasar, yava≈ü atƒ±≈ü.',f:()=>{game.player.unlockedWeaps[3]=true; document.getElementById('w-3').classList.remove('locked');}});
        
        const shuffled = allOptions.sort(() => 0.5 - Math.random());
        const selected = shuffled.slice(0, 3);
        selected.forEach((p, index)=>{
            const d=document.createElement('div'); d.className='upgrade-card'; d.style.animationDelay = (index * 0.1) + 's';
            d.innerHTML=`<div>${p.i}</div><div>${p.t}</div><div style="font-size:14px; color:#aaa; margin-top:10px;">${p.desc}</div>`;
            d.onclick=()=>{ p.f(); s.style.display='none'; game.startGame(game.wave+1); };
            c.appendChild(d);
        });
        if(selected.length === 0) { s.style.display='none'; game.startGame(game.wave+1); } else { s.style.display='flex'; }
    }

    gameOver() {
        this.state='GAMEOVER'; document.getElementById('game-over').style.display='flex';
        document.getElementById('final-score').innerText=this.score;
        document.body.classList.add('in-menu'); document.getElementById('game-ui').style.display='none';
        if(this.score>this.data.hs) { this.data.hs=this.score; SaveSystem.save(this.data); }
    }

    draw() {
        // STATE LOADING CHECK
        if (this.state === 'LOADING') return;

        if(this.state==='CHAR_MENU') { this.player.drawPreview(this.prevCtx, this.prevId); return; }
        ctx.fillStyle='#050505'; ctx.fillRect(0,0,canvas.width,canvas.height);
        if(this.state==='MENU') { this.player.draw(ctx, this.cam); return; }

        if(this.q !== 'LOW') {
            const ox=-this.cam.x%100, oy=-this.cam.y%100;
            ctx.strokeStyle='rgba(0,243,255,0.05)'; ctx.lineWidth=1; ctx.beginPath();
            for(let x=ox;x<canvas.width;x+=100){ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);}
            for(let y=oy;y<canvas.height;y+=100){ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);}
            ctx.stroke();
        }

        this.walls.forEach(w=>{
            const dx=w.x-this.cam.x; const dy=w.y-this.cam.y;
            if(dx+w.w<0 || dx>canvas.width || dy+w.h<0 || dy>canvas.height) return;
            if(this.q === 'HIGH') { ctx.shadowBlur=15; ctx.shadowColor=w.color||'rgba(0,243,255,0.1)'; }
            ctx.fillStyle='#111'; ctx.fillRect(dx,dy,w.w,w.h);
            ctx.fillStyle='#1a1a2e'; ctx.fillRect(dx,dy,w.w,w.h-10);
            ctx.strokeStyle=w.color||'#00f3ff'; ctx.lineWidth=1; ctx.strokeRect(dx,dy,w.w,w.h-10);
            ctx.shadowBlur=0;
        });

        this.bullets.forEach(b=>b.draw(ctx,this.cam));
        this.enemies.forEach(e=>e.draw(ctx,this.cam, this.q));
        this.player.draw(ctx,this.cam);
        this.parts.forEach(p=>p.draw(ctx,this.cam));
        this.txts.forEach(t=>t.draw(ctx,this.cam));

        if(this.state==='PLAYING' || this.state==='TACTICAL') {
            ctx.save(); const px = this.player.x - this.cam.x; const py = this.player.y - this.cam.y;
            ctx.translate(px, py); ctx.rotate(this.player.ang);
            ctx.strokeStyle='rgba(0,255,0,0.1)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(20,0); ctx.lineTo(600,0); ctx.stroke(); ctx.restore();
            
            ctx.save(); ctx.translate(mouse.x, mouse.y);
            let crossColor = '#0f0';
            if(this.player.weap === 3) {
                 const mx = mouse.x + this.cam.x; const my = mouse.y + this.cam.y;
                 for(let e of this.enemies) if(Math.hypot(e.x - mx, e.y - my) < e.r + 10) crossColor = '#f00';
            }
            ctx.strokeStyle=crossColor; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(10,0); ctx.moveTo(0,-10); ctx.lineTo(0,10); ctx.stroke();
            if(crossColor === '#f00') { ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2); ctx.stroke(); }
            ctx.restore();
        }
        if(this.state === 'PLAYING') this.minimap.draw(this.player, this.enemies, this.walls, this.wW, this.wH);
    }
    loop() { this.update(); this.draw(); requestAnimationFrame(()=>this.loop()); }
}

window.addEventListener('load', () => { window.game = new Game(); window.game.loop(); });
</script>
</body>
</html>
